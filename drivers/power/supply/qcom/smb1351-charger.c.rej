diff a/drivers/power/supply/qcom/smb1351-charger.c b/drivers/power/supply/qcom/smb1351-charger.c	(rejected hunks)
@@ -11,6 +11,9 @@
  */
 
 #define pr_fmt(fmt) "SMB1351 %s: " fmt, __func__
+#ifdef CONFIG_LGE_PM_PARALLEL_CHARGING
+#define DEFINE
+#endif
 
 #include <linux/i2c.h>
 #include <linux/debugfs.h>
@@ -961,6 +969,9 @@ static int smb1351_fastchg_current_set(struct smb1351_charger *chip,
 	int i, rc;
 	bool is_pre_chg = false;
 
+#ifdef CONFIG_LGE_PM_PARALLEL_CHARGING
+	pr_err("%s - fastchg_current[%d]\n", __func__, fastchg_current);
+#endif
 	mutex_lock(&chip->fcc_lock);
 	if (fastchg_current < SMB1351_CHG_PRE_MIN_MA)
 		fastchg_current = SMB1351_CHG_PRE_MIN_MA;
@@ -2460,8 +2471,13 @@ static int smb1351_parallel_set_chg_present(struct smb1351_charger *chip,
 			}
 		}
 
+#ifdef CONFIG_LGE_PM_PARALLEL_CHARGING
+		/* set charging enable by I2C */
+		reg = EN_BY_I2C_0_ENABLE | USBCS_CTRL_BY_I2C;
+#else
 		/* set chg en by pin active low  */
 		reg = chip->parallel_pin_polarity_setting | USBCS_CTRL_BY_I2C;
+#endif
 		rc = smb1351_masked_write(chip, CHG_PIN_EN_CTRL_REG,
 					EN_PIN_CTRL_MASK | USBCS_CTRL_BIT, reg);
 		if (rc) {
@@ -2499,6 +2515,34 @@ static int smb1351_parallel_set_chg_present(struct smb1351_charger *chip,
 			pr_err("Couldn't set fastchg current rc=%d\n", rc);
 			return rc;
 		}
+
+#ifdef CONFIG_LGE_PM_PARALLEL_CHARGING
+		/* adapter allowance to 5~9V */
+		rc = smb1351_masked_write(chip, FLEXCHARGER_REG,
+				CHG_CONFIG_MASK, 0);
+
+		if (rc) {
+			pr_err("Couldn't set charger config adapter rc = %d\n", rc);
+			return rc;
+		}
+
+		/* jeita disable */
+		rc = smb1351_masked_write(chip, THERM_A_CTRL_REG,
+				SOFT_COLD_TEMP_LIMIT_MASK, 0);
+		if (rc) {
+			pr_err("Couldn't set soft cold limit rc = %d\n", rc);
+			return rc;
+		}
+
+		rc = smb1351_masked_write(chip, THERM_A_CTRL_REG,
+				SOFT_HOT_TEMP_LIMIT_MASK, 0);
+
+		if (rc) {
+			pr_err("Couldn't set soft hot limit rc = %d\n", rc);
+			return rc;
+		}
+#endif
+
 		/*
 		 * Suspend USB input (CURRENT reason) to avoid slave start
 		 * charging before any SW logic been run. USB input will be
@@ -2561,6 +2605,10 @@ static int smb1351_parallel_set_property(struct power_supply *psy,
 				pr_err("%suspend charger failed\n",
 						val->intval ? "Un-s" : "S");
 		}
+#ifdef CONFIG_LGE_PM_PARALLEL_CHARGING
+		else
+			chip->usb_suspended_status &= ~USER;
+#endif
 		break;
 	case POWER_SUPPLY_PROP_PRESENT:
 		mutex_lock(&chip->parallel_config_lock);
@@ -2734,7 +2782,11 @@ static void smb1351_chg_ctrl_in_jeita(struct smb1351_charger *chip)
 static void smb1351_chg_adc_notification(enum qpnp_tm_state state, void *ctx)
 {
 	struct smb1351_charger *chip = ctx;
+#ifdef CONFIG_LGE_PM
+	struct battery_status *cur = NULL;
+#else
 	struct battery_status *cur;
+#endif
 	int temp;
 
 	if (state >= ADC_TM_STATE_NUM) {
@@ -2833,7 +2885,12 @@ static void smb1351_chg_adc_notification(enum qpnp_tm_state state, void *ctx)
 				chip->batt_hot_decidegc + HYSTERESIS_DECIDEGC;
 		}
 	}
-
+#ifdef CONFIG_LGE_PM
+	if (!cur) {
+		pr_err("no new status with state:%d,temp:%d\n", state,temp);
+		return;
+	}
+#endif
 	if (cur->batt_present)
 		chip->battery_missing = false;
 	else
@@ -3647,9 +3704,13 @@ static int smb1351_update_usb_supply_icl(struct smb1351_charger *chip)
 {
 	int rc, type, icl;
 	union power_supply_propval pval = {0, };
-
+#ifdef CONFIG_LGE_PM
+	rc = chip->usb_psy->get_property(chip->usb_psy,
+			POWER_SUPPLY_PROP_REAL_TYPE, &pval);
+#else
 	rc = chip->usb_psy->get_property(chip->usb_psy,
 			POWER_SUPPLY_PROP_TYPE, &pval);
+#endif
 	if (rc) {
 		pr_err("Get USB supply type failed, rc=%d\n", rc);
 		return rc;
@@ -4667,8 +4728,11 @@ static int smb1351_parallel_slave_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, chip);
 	mutex_init(&chip->parallel_config_lock);
-
+#ifdef CONFIG_LGE_PM
+	chip->parallel_psy.name		= "usb-parallel";
+#else
 	chip->parallel_psy.name		= "parallel";
+#endif
 	chip->parallel_psy.type		= POWER_SUPPLY_TYPE_PARALLEL;
 	chip->parallel_psy.get_property	= smb1351_parallel_get_property;
 	chip->parallel_psy.set_property	= smb1351_parallel_set_property;
